# $Id: mcs_cust.tcl,v 1.1.1.1 2011/10/04 10:54:25 xbourgui Exp $
namespace eval ADMIN::MCS_CUST {

asSetAct ADMIN::MCS_CUST::GoMCSBalance       [namespace code go_mcs_balance]
asSetAct ADMIN::MCS_CUST::GoOkToDelete       [namespace code go_cpm_ok_to_delete]

variable AFF_NAMES

# Set up user-friendly names for the casinos
set AFF_NAMES(CASINO_RIO) {Rio Bay Casino}

proc log_mcs {level msg} {
	OT_LogWrite $level "MCS: $msg"
}

# ----------------------------------------------------------------------------
# Retrieves account balance from Microgaming systems. Please rewrite me.
# ----------------------------------------------------------------------------
proc go_mcs_balance {} {
	global XML_RESPONSE BALANCE

	set BALANCE ""
	set mode        [reqGetArg mode]
	set username    [urlencode [reqGetArg username]]
	set mcs_BALANCE [OT_CfgGet MCS_CHECK_BAL_URL]
	set mcs_TIMEOUT [OT_CfgGet MCS_TIMEOUT]

	set aff_list [list ""]
	if {$mode == "CASINO"} {
		lappend aff_list "_RIO"
	}

	foreach aff $aff_list {

		set mcs_URL     [OT_CfgGet MCS_${mode}_BASE_URL${aff}]
		set url [format "%s%sloginname=%s" $mcs_URL $mcs_BALANCE $username]

		log_mcs 4 "calling mcs with url:$url"

		# grab the response (use timeout)
		if {[catch {set http_response [http::geturl $url -timeout $mcs_TIMEOUT]}]} {
			log_mcs 3 "failed to get mcs ${mode}${aff} balance (timeout)"
			append BALANCE "[_get_aff_name CASINO${aff}] :  FAILED<br />"
			continue
		}

		set response [validateResponse $http_response]

		# check ok
		if {$response != "OK"} {
			log_mcs 3 "failed to get mcs ${mode}${aff} balance (response = $response)"
			append BALANCE "[_get_aff_name CASINO${aff}] :  FAILED<br />"
			continue
		}

		# parse the data
		parseBody [http::data $http_response]
		# clean up the html
		http::cleanup $http_response

		# now check the response
		if {[info exists XML_RESPONSE(getbalance,result)]} {
			if {$XML_RESPONSE(getbalance,result) == "QRY_OK"} {
				log_mcs 4 "mcs $mode $aff balance retrieved ok"
				append BALANCE "[_get_aff_name ${mode}${aff}] :  $XML_RESPONSE(getbalance,balance) <br />"
			} else {
				log_mcs 6 "XML RESPONSE = [array get XML_RESPONSE]"
				if {($mode == "POKER") && [info exists XML_RESPONSE(getbalance,errorcode)] && ($XML_RESPONSE(getbalance,errorcode) == "116")} {
					log_mcs 6 "code 116 detected"
					tpBindString Balance NOALIAS
					asPlayFile -nocache xgame_balance.html
					return
				}
				log_mcs 3 "failed to get mcs ${mode}${aff} balance (qry failed)"
				append BALANCE "[_get_aff_name ${mode}${aff}] :  FAILED"
				continue
			}
		} else {
			log_mcs 3 "failed to get mcs ${mode}${aff} balance (unknown failure)"
			append BALANCE "[_get_aff_name CASINO${aff}] :  FAILED"
			continue
		}
	}

	tpBindString Mode $mode
	tpBindString Balance $BALANCE
	asPlayFile -nocache xgame_balance.html
	return
}
# does the customer have an active MCS account,
# checks the MCS system
proc get_mcs_account_active {} {

	global XML_RESPONSE

	# get url timeout in milleseconds
	set TIMEOUT             [OT_CfgGet MCS_TIMEOUT]
	set action_string "/acct_exists.asp?"

	set mcs_URL     [OT_CfgGet MCS_BASE_URL]
	set username    [string map {" " "%20"} [reqGetArg username]]

	set url [format "%s%sloginname=%s" $mcs_URL $action_string $username]
	log_mcs 4 "calling mcs with url:$url"

	# grab the response (use timeout)
	if {[catch {set http_response [http::geturl $url -timeout $TIMEOUT]} msg]} {
		log_mcs 3 "failed to retrieve casino account status (network): $msg"
		return FAILED
	}

	# check ok
	set response [validateResponse $http_response]
	if {$response != "OK"} {
		log_mcs 3 "failed to retrieve mcs account status (response = $response)"
		return FAILED
	}

	# parse the data
	parseBody [http::data $http_response]

	# clean up the html
	http::cleanup $http_response

	# now check the response
	if {[info exists XML_RESPONSE(acct_exists,result)]} {
		if {$XML_RESPONSE(acct_exists,result) == "QRY_OK"} {
			return $XML_RESPONSE(acct_exists,exists)
		} else {
			return FAILED
		}
	}
	return FAILED
}

# Sends registration information to MicroGaming.
# Parameter cust_id required for setting Openbet DB flag
proc do_mcs_registration {cust_id} {

	global XML_RESPONSE
	global DB

	set TIMEOUT	[OT_CfgGet MCS_TIMEOUT 50000]

	if {![string length [reqGetArg username]]} {
		# if the username is blank, we probably autogenerated one at registration - retrieve it
		set sql { select username from tcustomer where cust_id = ? }
		set stmt [inf_prep_sql $DB $sql]
		set rs   [inf_exec_stmt $stmt $cust_id]
		if {[db_get_nrows $rs] == 1} {
			reqSetArg username [db_get_col $rs 0 username]
		}
		inf_close_stmt $stmt
	}

#	Check if MCS is up & if account exists on MCS system
	set res [get_mcs_account_active]

	#Some sort of communication error
	if {$res == "FAILED"} {
		return [list 1 "Error connecting to Microgaming site"]
	} elseif {$res != 0} {
		# Account already exists
		return [list 1 "Microgaming account already exists with that username"]
	}


	set password	[reqGetArg password]
	set sql {
		select
			flag_value
		from
			tcustomerflag
		where
			cust_id = ? and
			flag_name = ?
	}
	set stmt [inf_prep_sql $DB $sql]
	set rs   [inf_exec_stmt $stmt $cust_id poker_aff]

	inf_close_stmt $stmt

	if {[db_get_nrows $rs] == 1} {
		set bannertag   [db_get_col $rs 0 flag_value]
	} else {set bannertag lbr}
	log_mcs 99      "bannertag is $bannertag"
	set usertype    0

	set username    [string map {" " "%20"} [reqGetArg username]]
	set currency    GBP

	set aff_list [list "" "_RIO"]
	foreach aff $aff_list {

		set mcs_URL     [OT_CfgGet MCS_BASE_URL${aff}]

			# We need to pass details onto the microgaming web server
			# because casino account activation is compulsory
			# If registering through game download, use reguser.asp
			# If registering through sportsbook, use adduser.asp

		set balance         0
		set city	    [reqGetArg addr_city]
		set method          "adduser"
		set action_string   "/adduser.asp?"

		set url             [format "%s%sloginname=%s&password=%s&usertype=%s&balance=%s&city=%s&currency=%s&bannertag=%s"         $mcs_URL $action_string $username $password $usertype $balance $city $currency $bannertag]
		set log_url         [format "%s%sloginname=%s&password=<password>&usertype=%s&balance=%s&city=%s&currency=%s&bannertag=%s" $mcs_URL $action_string $username           $usertype $balance $city $currency $bannertag]
		set encoded_url     [string map {" " "%20"} $url]
		set log_encoded_url [string map {" " "%20"} $log_url]
		log_mcs 4 "calling mcs with url:$log_encoded_url"

		# grab the response (use timeout)
		if [catch {set http_response [http::geturl $encoded_url -timeout $TIMEOUT]}] {
			return [list 1 "Failed to contact system. Please activate your account at a later date"]
		}

		# check ok
		set response [validateResponse $http_response]
		if {$response != "OK"} {
			return [list 1 "Failed to activate account: No or incomplete response received from MCS (response = $response)"]
		}

		# parse the data
		parseBody [http::data $http_response]

		# clean up the html
		http::cleanup $http_response

		# now check the response
		if {[info exists XML_RESPONSE($method,result)]} {
			if {$XML_RESPONSE($method,result) == "QRY_OK"} {
				log_mcs 4 "successfully activated mcs$aff account"
				#next loop
			} else {
				tpBindString MCS_OPTIONS "&mcs_status=1"
				return [list 1 "Failed to activate account: $XML_RESPONSE($method,comment)"]
			}
		} else {
			log_mcs 2 "unrecognised response from mcs system"
			err_bind "Failed to activate account: No or incomplete response received from MCS, transaction aborted"
			return [list 1 "Failed to activate account: No or incomplete response received from MCS, transaction aborted"]
		}
	}

	ob_set_mcs_active $cust_id

	# don't check mcs status (we know that its ok) but bind options here
	tpBindString MCS_OPTIONS "&mcs_status=2"
	return [list 0 "OK"]

}

# Sets flag in openbet db to indicate that
# MCS account is active.
proc ob_set_mcs_active {cust_id} {

	global DB

	set username [reqGetArg username]
	# mark the casino a/c as active in openbet
	log_mcs 7 "activating mcs account in openbet (username=$username cust_id=$cust_id)"

	set sql [subst {
		execute procedure pUpdCustFlag
		(
			p_cust_id		= ?,
			p_flag_name		= "MCS_ACTIVE",
			p_flag_value	= "Y"
		)
		}]
	set stmt [inf_prep_sql $DB $sql]
	if [catch {inf_exec_stmt $stmt $cust_id} msg] {
		log_mcs 1 "Failed to set mcs account active in openbet system for customer $cust_id: $msg"
	}
	inf_close_stmt $stmt
}

proc reset_poker_srp {cust_id} {
	#srobins
	#PENDING - make this use a generic helper procedure.
	global DB

	set level       1

	#insert/update flag
	set sql {
			select
				flag_value
			from
				tcustomerflag
			where
				cust_id = ?
				and flag_name = "poker_srp_lev"
	}
	set stmt          [inf_prep_sql $DB $sql]
	set res_poker_srp [inf_exec_stmt $stmt $cust_id]

	inf_close_stmt $stmt

		#get ccy
		set sql {
			SELECT ccy_code
			FROM   tacct
			WHERE  cust_id = ?
		}
		set stmt    [inf_prep_sql $DB $sql]
		set res_ccy [inf_exec_stmt $stmt $cust_id]
		set ccy [db_get_col $res_ccy 0 ccy_code]
		inf_close_stmt $stmt



	OT_LogWrite 99 "number of rows returned: [db_get_nrows $res_poker_srp]"
	if {[db_get_nrows $res_poker_srp] == "1"} {
		if {[db_get_col	$res_poker_srp 0 flag_value] == $level} {
			#No need to carry on if level is already 1
			return
		}

		set sql {
				update
					tcustomerflag
				set
					flag_value = ?
				where
					cust_id = ?
					and flag_name = "poker_srp_lev"
			}
		set stmt    [inf_prep_sql $DB $sql]
		inf_exec_stmt $stmt $level $cust_id
		inf_close_stmt $stmt
	} else {
		set sql {
				insert into
					tcustomerflag
					(cust_id, flag_name, flag_value)
				values
					(?, "poker_srp_lev", ?)
		}

		set stmt [inf_prep_sql $DB $sql]

		inf_exec_stmt $stmt $cust_id $level
		inf_close_stmt $stmt
	}
	db_close $res_poker_srp

	# Level is 0,1,2 or 3 - default is 1
	# Get max allowable deposit over 10 days
	# Txn limits may have changed even if level remains same.
	switch $level {

		3 {

			set max_dep [reqGetArg poker_max_dep]
			set max_wtd [reqGetArg poker_max_wtd]
		}

		2 -
		1 {

			set max_dep [ADMIN::CUST::convert_to_rounded_ccy [OT_CfgGet MCS_POKER_MAX_DEP_LEV_$level] $ccy]
			set max_wtd [ADMIN::CUST::convert_to_rounded_ccy [OT_CfgGet MCS_POKER_MAX_WTD_LEV_$level] $ccy]

		}

		default {

			set max_dep 0
			set max_wtd 0
		}
	}

	#change deposit/withdrawl values
	set sql {
		execute procedure pInsCustLimits
		(
			p_cust_id = ?,
			p_limit_type = ?,
			p_limit_value = ?
		)
	}

	set stmt [inf_prep_sql $DB $sql]

	inf_exec_stmt $stmt $cust_id poker_max_dep $max_dep

	inf_exec_stmt $stmt $cust_id poker_max_wtd $max_wtd
}

proc update_password {cust_id new_pwd} {

	global DB

	OT_LogWrite 5 "Customer MCS account = [reqGetArg MCSStatus]"
	# If updating MCS server with password changes
	# retrieve required information from DB and
	# call update_mcs_password procedure.
	if {[reqGetArg MCSStatus] == "Y"} {

		set sql2 {
			select
				username
			from
				tcustomer
			where
				cust_id = ?
		}

		set stmt2 [inf_prep_sql $DB $sql2]

		set c2 [catch {set res2 [inf_exec_stmt $stmt2 $cust_id]} msg2]

		if {$c2 != 0} {
			err_bind $msg2
			return
		}

		if {[db_get_nrows $res2] != 1} {
			OT_LogWrite 3 "Error. Query returned invalid number of results."
			err_bind "Error retrieving customer information. Update failed."
			inf_close_stmt $stmt2
			return
		}

		set username [db_get_col $res2 username]
		db_close $res2
		inf_close_stmt $stmt2

		OT_LogWrite 5 "Update the customer's MCS password."

		update_mcs_password $username $new_pwd

	} else {
		err_bind "Customer does not have MCS_ACTIVE set as 'Y' in openbet system"
		return
	}
}
#
# ----------------------------------------------------------------------------
# Reset a customer's MCS password
# ----------------------------------------------------------------------------
#
proc update_mcs_password {username new_pwd} {

	global XML_RESPONSE

	lappend aff_list ""
	lappend aff_list "_RIO"

	foreach aff $aff_list {

		set mcs_URL     [OT_CfgGet MCS_BASE_URL${aff}]
		set mcs_RESET   [OT_CfgGet MCS_RESET_PASS_URL]
		set mcs_CHECK   [OT_CfgGet MCS_CHECK_ACCT_URL]
		set mcs_TIMEOUT [OT_CfgGet MCS_TIMEOUT]

		set username    [string map {" " "%20"} $username]
		set url         [format "%s%sloginname=%s" $mcs_URL $mcs_CHECK $username]
		OT_LogWrite 4 "Calling mcs with url:$url"

		# grab the response (use timeout)
		if {[catch {set http_response [http::geturl $url -timeout $mcs_TIMEOUT]} msg]} {
			OT_LogWrite 3 "Failed to retrieve casino account status (network): $msg"
			return
		}

		# check ok
		set response [validateResponse $http_response]
		if {$response != "OK"} {
			OT_LogWrite 3 "Failed to update casino password (timeout)"
			err_bind "Can't contact casino system."
			return
		}

		# parse the data
		parseBody [http::data $http_response]

		# clean up the html
		http::cleanup $http_response

		# now check the response
		if {[info exists XML_RESPONSE(acct_exists,result)]} {
			if {$XML_RESPONSE(acct_exists,result) == "QRY_OK"} {
				if {$XML_RESPONSE(acct_exists,exists) == 1} {
					set url     [format "%s%sloginname=%s&newpassword=%s" $mcs_URL $mcs_RESET $username $new_pwd]
					set log_url [format "%s%sloginname=%s&newpassword=<new_passwd>" $mcs_URL $mcs_RESET $username]
					OT_LogWrite 4 "Calling mcs with url:$log_url"

					# grab the response (use timeout)
					if [catch {set http_response [http::geturl $url -timeout $mcs_TIMEOUT]}] {
						OT_LogWrite 3 "Failed to update casino password (timeout)"
						err_bind "Can't contact casino system."
						return
					}

					# check ok
					set response [validateResponse $http_response]
					if {$response != "OK"} {
						OT_LogWrite 3 "Failed to reset casino password (response = $response)"
						err_bind "No or incomplete response received from MCS"
						return
					}
					# parse the data
					parseBody [http::data $http_response]

					# clean up the html
					http::cleanup $http_response

					# now check the response
					if {[info exists XML_RESPONSE(resetpassword,result)]} {
						if {$XML_RESPONSE(resetpassword,result) == "QRY_OK"} {
							OT_LogWrite 4 "Ladbrokes${aff} Password reset successfully"
							#next loop
						} else {
							OT_LogWrite 3 "Failed to reset casino password (qry failed: $XML_RESPONSE(resetpassword,comment))"
							err_bind "Failed to reset casino password (qry failed)"
							return
						}
					}
				} else {
					OT_LogWrite 3 "The customer $username does not have an MCS account."
					err_bind "WARNING: The customer does not have an MCS account."
					return
				}
			} else {
				OT_LogWrite 3 "Unrecognised response from mcs"
				err_bind "No or incomplete response received from MCS, transaction aborted"
				return
			}
		}
	}
	OT_LogWrite 4 "All passwords reset successfully"
}

#
# ----------------------------------------------------------------------------
# Look up the user-friendly version of the aff name
# ----------------------------------------------------------------------------
#
proc _get_aff_name {aff} {
	variable AFF_NAMES

	if {[info exists AFF_NAMES($aff)]} {
		return $AFF_NAMES($aff)
	} else {
		return $aff
	}
}

#----------------------------------------------------------------------------
#
# Code to check if a customer's card can be deleted. Displays a screen
# displaying why the the customer's cpm cannot be deleted.
#
#----------------------------------------------------------------------------
proc go_cpm_ok_to_delete {} {

	global DB

	#
	# Retrieve the customer's details
	#
	set username  [reqGetArg username]
	set cust_id   ""
	set balance   ""
	set sql {
		select
			c.cust_id,
			a.balance
		from
			tCustomer c,
			tAcct a
		where
			c.cust_id = a.cust_id and
			c.username = ?
	}
	set stmt [inf_prep_sql $DB $sql]
	set rs   [inf_exec_stmt $stmt $username]


	if {[db_get_nrows $rs] == 1} {
		set cust_id    [db_get_col $rs 0 cust_id]
		set balance    [db_get_col $rs 0 balance]

		#
		# Make the call to see if it's ok to delete
		#
		set       results     [card_util::verify_cust_card_ok_to_delete $cust_id]
		set       success     [lindex $results 0]
		tpSetVar  RES_success $success


		#
		# Take info from the call and bind it
		# up for the template.
		#
		set TRANS(0) "Failed"
		set TRANS(1) "Passed"
		set TRANS(2) "Unable to verify at present"
		set TRANS(3) "Not tested"

		# unforunately this list has to match the list returned from
		# card_util::verify_cust_card_ok_to_delete so that the binding
		# works for the template.
		set lookup [list \
						bal cas_bal rb_cas_bal \
						vip_cas_bal poker_bal unstl_bets \
						state_games balls live_dealer \
						pmt_pend cantorfof ggrecentstake \
						ctxm_game unknown_xfer playtech_cas_bal
				   ]

		set idx 1
		foreach item $lookup {
			foreach {ret msg code} [lindex $results $idx] {}

			# if there is a problem with unknown_xfer - highlight the error as not a customer specific error
			# but something wrong with the ok_to_delete process itself - new entry in txsyshost not handled by
			# verify_cust_card_ok_to_delete
			if {$item == "unknown_xfer"} {
				if {$ret == 2 || $ret == 0} {
					err_bind $msg
				}
			} else {

				tpBindString RES_${item}_ok $ret
				tpBindString TXT_${item}_ok $TRANS($ret)
				tpBindString MSG_${item}    $msg
			}

			incr idx
		}


	} else {
		err_bind "Customer not found."
	}
	db_close $rs


	#
	# Tidy up and return
	#
	asPlayFile -nocache pmt/ok_to_delete.html
	return
}


}
